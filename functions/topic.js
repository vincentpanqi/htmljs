// Generated by CoffeeScript 1.9.3
(function() {
  var Tag, Topic, TopicComment, TopicZanLogs, User, func_topic;

  Topic = __M('topics');

  TopicComment = __M('topic_comments');

  User = __M('users');

  User.hasOne(Topic, {
    foreignKey: "user_id"
  });

  Topic.belongsTo(User, {
    foreignKey: "user_id"
  });

  Tag = __M('topic/tags');

  Tag.hasOne(Topic, {
    foreignKey: "tag_id"
  });

  Topic.belongsTo(Tag, {
    foreignKey: "tag_id"
  });

  TopicZanLogs = __M('topic_zan_logs');

  User.hasOne(TopicZanLogs, {
    foreignKey: "user_id"
  });

  TopicZanLogs.belongsTo(User, {
    foreignKey: "user_id"
  });

  TopicZanLogs.sync();

  Topic.sync();

  TopicComment.sync();

  func_topic = {
    run_sort: function() {
      var self;
      self = this;
      return this.getAllByField(1, 10000, null, function(error, articles) {
        if (articles && articles.length) {
          return articles.forEach(function(a) {
            return self.run_sort_byid(a.id);
          });
        }
      });
    },
    run_sort_byid: function(articleId) {
      return Topic.find({
        where: {
          id: articleId
        }
      }).success(function(article) {
        var score;
        if (article && article.last_comment_time) {
          score = (article.comment_count + article.visit_count / 100) / Math.pow((new Date().getTime() - article.last_comment_time.getTime()) / 1000 / 60 / 60 + 2, 1.5);
          return article.updateAttributes({
            score: score
          }, ['score']).success(function() {});
        }
      }).error(function(error) {
        return callback(error);
      });
    },
    getAllByField: function(page, count, condition, order, callback) {
      var query;
      if (!callback) {
        callback = order;
        order = "sort desc,id desc";
      }
      query = {
        offset: (page - 1) * count,
        limit: count,
        order: order,
        attributes: ['id', 'last_comment_time', 'comment_count', 'visit_count'],
        raw: false
      };
      if (condition) {
        query.where = condition;
      }
      return Topic.findAll(query).success(function(articles) {
        return callback(null, articles);
      }).error(function(error) {
        return callback(error);
      });
    },
    getById: function(id, callback) {
      return Topic.find({
        where: {
          id: id
        },
        raw: true,
        include: [User, Tag]
      }).success(function(topic) {
        if (!topic) {
          return callback(new Error('不存在的话题'));
        } else {
          return callback(null, topic);
        }
      }).error(function(e) {
        return callback(e);
      });
    },
    getAll: function(page, count, condition, order, include, callback) {
      var query;
      if (arguments.length === 4) {
        callback = order;
        order = null;
        include = null;
      } else if (arguments.length === 5) {
        callback = include;
        include = null;
      }
      query = {
        offset: (page - 1) * count,
        limit: count,
        order: order || "id desc",
        include: [Tag],
        raw: true
      };
      if (condition) {
        query.where = condition;
      }
      return Topic.findAll(query).success(function(ms) {
        return callback(null, ms);
      }).error(function(e) {
        return callback(e);
      });
    },
    addZan: function(topic_id, user_id, score, callback) {
      score = score * 1;
      return TopicZanLogs.find({
        where: {
          topic_id: topic_id,
          user_id: user_id
        }
      }).success(function(log) {
        if (log) {
          return callback(new Error('已经赞过这个话题了哦'));
        } else {
          return Topic.find({
            where: {
              id: topic_id
            }
          }).success(function(topic) {
            if (!topic) {
              return callback(new Error('不存在的话题'));
            } else {
              return TopicZanLogs.create({
                topic_id: topic_id,
                user_id: user_id
              }).success(function(log) {
                topic.updateAttributes({
                  zan_count: topic.zan_count * 1 + 1
                });
                return callback(null, log, topic);
              }).error(function(e) {
                return callback(e);
              });
            }
          }).error(function(e) {
            return callback(e);
          });
        }
      }).error(function(e) {
        return callback(e);
      });
    },
    getZansByTopicId: function(topic_id, callback) {
      return TopicZanLogs.findAll({
        where: {
          topic_id: topic_id
        },
        include: [User],
        order: "id desc",
        raw: true
      }).success(function(logs) {
        return callback(null, logs);
      }).error(function(e) {
        return callback(e);
      });
    }
  };

  __FC(func_topic, Topic, ['add', 'delete', 'update', "count", "addCount"]);

  module.exports = func_topic;

}).call(this);
